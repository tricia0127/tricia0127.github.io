<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SERENDIPITY</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http:/"/>
  <updated>2018-01-16T10:34:38.439Z</updated>
  <id>http:/</id>
  
  <author>
    <name>Tricia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python实现基于哈夫曼算法的加解密工具</title>
    <link href="http:/2017/11/16/python%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%A0%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/"/>
    <id>http:/2017/11/16/python实现基于哈夫曼算法的加解密工具/</id>
    <published>2017-11-16T15:49:13.000Z</published>
    <updated>2018-01-16T10:34:38.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-写在开头"><a href="#1-写在开头" class="headerlink" title="1.写在开头"></a>1.写在开头</h2><p>本学期程序设计周的题目，利用哈夫曼算法实现了一个加解密的工具。</p>
<p>基本要求：<br>(1) 根据给定的单词字典库，为每个单词配置一个随机数作为权重，利用哈夫曼算法为各单词生成对应的密文，从而构造密码字典；<br>(2) 利用密码字典实现对输入文件的加解密；<br>(3) 界面友好、直观；<br>提高要求：<br>(1)    按照基本要求实现的加解密系统无法抵抗基于单词频度分析的攻击，试设计能够抵御频度分析攻击的基于哈夫曼算法的加解密方法（提示：可以采用多密码字典混合加解密的方法，加密时随机选择某一个密码字典）；<br>(2)    当密码字典规模较大时，加解密的性能必然受到影响，试设计好的算法提高加解密的效率。<br>课题理解：<br>一般哈夫曼算法多用于文件、图片的解压缩，但此题目主要是希望我们做一个利用哈夫曼算法做一个加解密的工具。通过构造哈夫曼树，我们可以获得各个英文单词所对应的编码。需要的功能有：从文件导入明文，随机选择一个密码字典对其加密并生成密文，将密文保存到文件。<br>在编写各项功能前，需要自己收集单词字典素材，我选择通过去维基百科找一篇文章，利用正则匹配的方法将所有英文单词匹配下来，再进行去重的方法做了一个密码字典，其中包含了上千个不重复的英文单词。<br>另外需要注意的是，为了保证加密程序的安全性和可靠性，只采用一个字典库是不够的，为了抵御频度攻击，在后期的设计上，应考虑采用多密码字典混合加解密的方法对明密文处理，以获得一个性能优良、安全性高的加解密工具。<br>此程序需要有gui的界面，以达到用户友好地交互功能。<br><br></p>
<h2 id="2-数据结构说明"><a href="#2-数据结构说明" class="headerlink" title="2.数据结构说明"></a>2.数据结构说明</h2><p><img src="http://ojv7wbfak.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png" alt="image"><br>这里简单罗列了几种程序中用到的数据结构形式。<br>在正则匹配单词生成字典并给单词随机赋权值的时候，单词库是以python中“字典”的数据结构进行存储的。这种数据结构的独特之处在于：字典是一种可变容器模型，且可存储任意类型对象。字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：<br>d = {key1 : value1, key2 : value2 }<br><br><br></p>
<h2 id="3-算法设计"><a href="#3-算法设计" class="headerlink" title="3.算法设计"></a>3.算法设计</h2><p>程序导入了三个模块，分别为<br>HuffmanTree.py，NodeDataIO.py，decode.py。<br>以下对各模块做具体分析。 <br>   </p>
<h3 id="3-1HuffmanTree-py模块"><a href="#3-1HuffmanTree-py模块" class="headerlink" title="3.1HuffmanTree.py模块"></a>3.1HuffmanTree.py模块</h3><p><img src="http://ojv7wbfak.bkt.clouddn.com/HuffmanTree.py%E6%A8%A1%E5%9D%97.png" alt="image"><br></p>
<h4 id="3-1-1-class-TreeNode"><a href="#3-1-1-class-TreeNode" class="headerlink" title="3.1.1 class TreeNode"></a>3.1.1 class TreeNode</h4><p>用于存储哈夫曼树的节点结构。存储了左孩子、右孩子、字符、权值、编码、父节点等属性。<br></p>
<h4 id="3-1-2-class-HuffmanTree"><a href="#3-1-2-class-HuffmanTree" class="headerlink" title="3.1.2 class HuffmanTree"></a>3.1.2 class HuffmanTree</h4><p>主要功能是构造哈夫曼树，算上类的构造函数<strong>init</strong>，一共有12个方法。<br><strong>nodesToObject(self, nodeList)：将字符和对应权值以python的列表结构存储。    
</strong>createTree(self, nodeList)：用给定的节点列表nodeList 创建哈夫曼树，返回根节点。<br>display(self, root)：打开tree.txt文档，为存储哈夫曼树做准备。<br><strong>display(self, root, level = ‘’)：使用缩进格式在文件中输出哈夫曼树。  
</strong>encode(self, root)：给每个树节点相应的编码值。<br>getTree(self)：获取以nodeList为节点的哈夫曼树。<br>findNode(self, root, value)：获取值为value的节点。<br>__goForAncesstor(self, node, encoding)：从叶子结点node开始，回到根节点，同时获取该节点的哈夫曼编码。<br>getCharEncoding(self, value)：获取字符value的哈夫曼编码。<br>getCharDecoding(self, encoding)：获取编码为encoding的字符。<br>reachAllLeafs(self, root)：遍历每个叶子，将每个字符的编码存入字典encodingList。  <br></p>
<h4 id="3-1-3-class-Encoding"><a href="#3-1-3-class-Encoding" class="headerlink" title="3.1.3 class Encoding"></a>3.1.3 class Encoding</h4><p>不包括类的构造函数，有以下三个方法：<br>getStringEncoding(self, string)：字符串加密，将明文中的单词与字典encodingList中的单词匹配，然后存入encoding作为密文。<br>getStringDecoding(self, encoding)：字符串解密，将密文编码与字典encodingList中的单词对应的编码匹配，转换成明文单词，然后存入字符串string。<br>compare(obj)：设置类TreeNode的比较器。  <br></p>
<h3 id="3-2-NodeDataIO-py模块"><a href="#3-2-NodeDataIO-py模块" class="headerlink" title="3.2 NodeDataIO.py模块"></a>3.2 NodeDataIO.py模块</h3><p><img src="http://ojv7wbfak.bkt.clouddn.com/NodeDataIO.py%E6%A8%A1%E5%9D%97.png" alt="image"><br><br>此模块的主要功能是节点信息的读取和存储。<br>class NodeDataIO类的初始化方法里实现的功能是在password dictionary文件夹中随机选择一个密码字典，是为“加密”功能服务的。属性中的fileName1就是随机选择的字典的文件名。<br>__readNextNode(self)：从文件中读取下一个结点的信息。<br>getNodes(self)：返回文件中所有节点信息构成的列表。<br>SaveNode(self, nodes)：将所有节点信息构成的列表存入文件。  <br></p>
<h3 id="3-3-decode-py模块"><a href="#3-3-decode-py模块" class="headerlink" title="3.3 decode.py模块"></a>3.3 decode.py模块</h3><p><img src="http://ojv7wbfak.bkt.clouddn.com/decode.py%E6%A8%A1%E5%9D%97.png" alt="image"><br><br>decode.py模块仅仅服务于解密，除了类的初始化方法，其余方法都和NodeDataIO.py模块中的相同。为了在多密码字典加密情况下解密可以一次性找到当时加密的字典，所以要通过该模块的初始化方法中获取到加密时密码字典的文件名。<br></p>
<h3 id="3-4-Dialog-pyw主要执行过程"><a href="#3-4-Dialog-pyw主要执行过程" class="headerlink" title="3.4 Dialog.pyw主要执行过程"></a>3.4 Dialog.pyw主要执行过程</h3><p><img src="http://ojv7wbfak.bkt.clouddn.com/Dialog.pyw%E4%B8%BB%E8%A6%81%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"><br><br></p>
<h2 id="4-详细设计"><a href="#4-详细设计" class="headerlink" title="4.详细设计"></a>4.详细设计</h2><h3 id="4-1-Dialog-pyw核心代码"><a href="#4-1-Dialog-pyw核心代码" class="headerlink" title="4.1 Dialog.pyw核心代码"></a>4.1 Dialog.pyw核心代码</h3><p>dictionary函数用于造单词字典，采用的方法是正则匹配英文文章中的每个英文单词，去重、排序后赋值，值为随机且不重复的2000以内的数值，给密码字典随机命名为 dictionary + random随机值 .txt的形式，为解密选择字典编号服务。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def dictionary(self): </div><div class="line">   f = open(<span class="string">"/Users/zhangchuyue/Desktop/分词+随机权重程序/test.txt"</span>) </div><div class="line">   <span class="keyword">try</span>: </div><div class="line">        <span class="built_in">text</span> = f.<span class="built_in">read</span>()  <span class="comment"># 读取整个文件并放入一个字符串变量中 </span></div><div class="line">        <span class="built_in">words</span> = re.findall(r<span class="string">"\b[a-zA-Z]&#123;1,50&#125;\b"</span>, <span class="built_in">text</span>)  <span class="comment"># 正则匹配所有英文单词得到一个列表 </span></div><div class="line">        results = [] </div><div class="line">        dictionary = &#123;&#125; </div><div class="line">        value = <span class="number">0</span> </div><div class="line">        li = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>)] </div><div class="line">        li1 = random.sample(li, <span class="number">2000</span>) </div><div class="line">        <span class="keyword">for</span> <span class="built_in">word</span> <span class="keyword">in</span> <span class="built_in">words</span>: </div><div class="line">            <span class="literal">result</span> = <span class="built_in">word</span>.lower()  <span class="comment"># 将英文单词全部转为小写 </span></div><div class="line">            results.append(<span class="literal">result</span>) </div><div class="line">        results = <span class="built_in">list</span>(<span class="keyword">set</span>(results))  <span class="comment"># 将匹配结果存储在列表里并用set函数去除重复单词 </span></div><div class="line">        results.sort()  <span class="comment"># 对列表排序 </span></div><div class="line">        <span class="keyword">for</span> <span class="literal">result</span> <span class="keyword">in</span> results: </div><div class="line">            dictionary[<span class="literal">result</span>] = li1[value]     <span class="comment"># 单词为字典的键，随机数为值，作为每个单词的权重 </span></div><div class="line">            value += <span class="number">1</span> </div><div class="line">        <span class="built_in">number</span> = random.randint(<span class="number">100</span>, <span class="number">999</span>) </div><div class="line">        output = open(<span class="string">"/Users/zhangchuyue/Desktop/B15040805张楚月_哈夫曼加解密工具/password dictionary/dictionary%d.txt"</span> % <span class="built_in">number</span>, <span class="string">"w"</span>)  </div><div class="line">        print(dictionary) </div><div class="line">        print(<span class="string">"create password dictionary："</span> + <span class="string">"dictionary%d.txt"</span> % <span class="built_in">number</span>) </div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dictionary: </div><div class="line">            output.writelines(key + <span class="string">":"</span> + str(dictionary[key]) + <span class="string">"\n"</span>)     <span class="comment"># 字典内容写入文件 </span></div><div class="line">        output.close() </div><div class="line">   finally: </div><div class="line">        f.close()</div></pre></td></tr></table></figure>
<p>实例化类NodeDataIO()和HuffmanTree，获得实例对象，用于输出哈夫曼树tree.txt。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printTree</span><span class="params">(<span class="keyword">self</span>)</span></span>: </div><div class="line">    io = NodeDataIO() </div><div class="line">    nodeList = io.getNodes() </div><div class="line">    tree = HuffumanTree(nodeList) </div><div class="line">    tree.display(tree.getTree()) </div><div class="line">    os.system(<span class="string">'notepad tree.txt'</span>) </div><div class="line">    <span class="keyword">return</span> io</div></pre></td></tr></table></figure>
<p>def transform(self)用于字符转化为编码形式，实例化类NodeDataIO()和HuffmanTree，获得实例对象，首先在NodeDataIO类中初始化方法随机选择出一个密码字典，然后通过NodeDataIO类中的函数获得节点列表，再调用HuffmanTree类中的函数构造字符和编码的字典，调用HuffmanTree类中的编码函数getStringEncoding(text)进行编码。此函数中的count = io.fileName1[10:13]得到的是所选用的字典文件名的字典编号，用于存储到密文开头，为解密服务。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(<span class="keyword">self</span>)</span></span>: </div><div class="line">io = NodeDataIO()     <span class="comment"># 实例化对象</span></div><div class="line">    nodeList = io.getNodes() </div><div class="line">    tree = HuffumanTree(nodeList) </div><div class="line">    encoder = Encoding(tree.encodingList) </div><div class="line">    count = io.fileName1[<span class="number">10</span><span class="symbol">:</span><span class="number">13</span>]      <span class="comment"># 将密码字典文件名中的随机三位数编号赋值给count</span></div><div class="line">    <span class="keyword">self</span>.count = count </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.encoding[<span class="string">'state'</span>] != <span class="string">'disabled'</span>)<span class="keyword">and</span>(<span class="keyword">self</span>.string[<span class="string">'state'</span>] != <span class="string">'disabled'</span>): </div><div class="line">            <span class="keyword">return</span> </div><div class="line">    elif(<span class="keyword">self</span>.encoding[<span class="string">'state'</span>] == <span class="string">'disabled'</span>)<span class="keyword">and</span>(<span class="keyword">self</span>.string[<span class="string">'state'</span>] != <span class="string">'disabled'</span>): </div><div class="line">        text = <span class="keyword">self</span>.string.get(<span class="string">'0.0'</span>, <span class="keyword">END</span>).strip(<span class="string">'\n'</span>) </div><div class="line">        <span class="symbol">try:</span> </div><div class="line">            encoding = bin(int(io.fileName1[<span class="number">10</span><span class="symbol">:</span><span class="number">13</span>]))[<span class="number">2</span><span class="symbol">:</span>] + encoder.getStringEncoding(text)   <span class="comment">#编码为开头以二进制形式呈现的字典标号和密文字符串</span></div><div class="line">        <span class="symbol">except:</span> </div><div class="line">            tkinter.messagebox.showerror(<span class="string">'错误'</span>, <span class="string">'您输入的文本中包含未编码的字符，请重新输入！'</span>) </div><div class="line">            <span class="keyword">return</span> </div><div class="line">        <span class="keyword">self</span>.encoding[<span class="string">'state'</span>] = <span class="string">'normal'</span> </div><div class="line">        <span class="keyword">self</span>.encoding.delete(<span class="string">'0.0'</span>, <span class="keyword">END</span>) </div><div class="line">        <span class="keyword">self</span>.encoding.insert(<span class="string">'0.0'</span>, encoding) </div><div class="line">        <span class="keyword">self</span>.__reset.focus_set()</div></pre></td></tr></table></figure>
<p>def decode(self)函数是专用于解密的函数，将字典编号以二进制形式存储在密文开头，解密时先以十进制形式的编号匹配相应字典，然后再用相应字典解密。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">def decode(self): </div><div class="line">    text = self.encoding.<span class="built_in">get</span>(<span class="string">'0.0'</span>, END).strip(<span class="string">'\n'</span>) </div><div class="line">    <span class="keyword">if</span> text.startswith(bin(<span class="keyword">int</span>(self.<span class="built_in">count</span>))[<span class="number">2</span>:]):   # 判断密文是否以二进制形式的加密所使用的密码字典的编号开头</div><div class="line">        text = text[<span class="built_in">len</span>(bin(<span class="keyword">int</span>(self.<span class="built_in">count</span>))[<span class="number">2</span>:]):]   # 编号匹配成功后，选择相应字典，跳过编号进行解密</div><div class="line">    <span class="keyword">global</span> de_fr </div><div class="line">de_fr = <span class="keyword">open</span>(<span class="comment">"/Users/zhangchuyue/Desktop/B15040805张楚月_哈夫曼加解密工具/password     </span></div><div class="line">       <span class="string">"dictionary/dictionary"</span> + self.<span class="built_in">count</span> + <span class="string">'.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) </div><div class="line">    <span class="keyword">new</span> = Decode(de_fr) </div><div class="line">    nodeList = <span class="keyword">new</span>.getNodes() </div><div class="line">    tree = HuffumanTree(nodeList) </div><div class="line">    encoder = Encoding(tree.encodingList) </div><div class="line">    <span class="keyword">try</span>: </div><div class="line">        <span class="built_in">string</span> = encoder.getStringDecoding(str(text)) </div><div class="line">    excep<span class="variable">t:</span> </div><div class="line">        tkinter.messagebox.showerror(<span class="string">'错误'</span>, <span class="string">'无法解码，请重新输入!'</span>) </div><div class="line">        <span class="keyword">return</span> </div><div class="line">    self.<span class="built_in">string</span>[<span class="string">'state'</span>] = <span class="string">'normal'</span> </div><div class="line">    self.<span class="built_in">string</span>.<span class="keyword">delete</span>(<span class="string">'0.0'</span>, END) </div><div class="line">    self.<span class="built_in">string</span>.<span class="keyword">insert</span>(<span class="string">'0.0'</span>, <span class="built_in">string</span>) </div><div class="line">self.__reset.focus_set()</div></pre></td></tr></table></figure>
<h3 id="4-2-HuffmanTree-py模块核心代码"><a href="#4-2-HuffmanTree-py模块核心代码" class="headerlink" title="4.2 HuffmanTree.py模块核心代码"></a>4.2 HuffmanTree.py模块核心代码</h3><p>def __createTree(self,nodeList)函数的功能是使用给定的节点列表nodeList创建哈夫<br>曼树，返回根节点。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def __createTree(self, nodeList): </div><div class="line">    nodeList.<span class="built_in">sort</span>(<span class="built_in">key</span> = <span class="built_in">compare</span>) </div><div class="line">    lchild = nodeList[<span class="number">0</span>] </div><div class="line">    nodeList.<span class="built_in">remove</span>(lchild) </div><div class="line">    rchild = nodeList[<span class="number">0</span>] </div><div class="line">    nodeList.<span class="built_in">remove</span>(rchild) </div><div class="line">    parent = TreeNode(lchild = lchild, rchild = rchild, </div><div class="line">                    weight = lchild.weight + rchild.weight) </div><div class="line">    <span class="keyword">if</span> len(nodeList) == <span class="number">0</span>: </div><div class="line">         <span class="built_in">return</span> parent </div><div class="line">    <span class="keyword">else</span>: </div><div class="line">        nodeList.<span class="built_in">append</span>(parent) </div><div class="line">        <span class="built_in">return</span> self.__createTree(nodeList)</div></pre></td></tr></table></figure>
<p>def __display(self,root,level = ‘’)使用缩进格式在文件中输出哈夫曼树，以tree.txt的形式保存在目录中。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__display</span><span class="params">(<span class="keyword">self</span>, root, level = <span class="string">''</span>)</span></span>: </div><div class="line">    <span class="keyword">if</span> level == <span class="string">''</span>: </div><div class="line">         <span class="keyword">self</span>.fw.write(level + repr(root) + <span class="string">'\n'</span>) </div><div class="line">    <span class="symbol">else:</span> </div><div class="line">        <span class="keyword">if</span> level[-<span class="number">4</span>] == <span class="string">' '</span>: </div><div class="line">            <span class="keyword">self</span>.fw.write(level[<span class="symbol">:-</span><span class="number">4</span>] + <span class="string">'└───'</span> + repr(root) + <span class="string">'\n'</span>) </div><div class="line">        <span class="symbol">else:</span> </div><div class="line">            <span class="keyword">self</span>.fw.write(level[<span class="symbol">:-</span><span class="number">3</span>] + <span class="string">'───'</span> + repr(root) + <span class="string">'\n'</span>) </div><div class="line"></div><div class="line">    <span class="keyword">if</span> root.lchild == <span class="symbol">None:</span> </div><div class="line">        <span class="keyword">return</span> </div><div class="line">    <span class="keyword">self</span>.__display(root. lchild, level + <span class="string">'│   '</span>) </div><div class="line"><span class="keyword">self</span>.__display(root. rchild, level + <span class="string">'    '</span>)</div></pre></td></tr></table></figure>
<p>HuffmanTree.py模块中，Encoding类中的方法是比较关键的，它们涉及到文件的加密和解密，最根本的加解密过程都是通过这个类里的加密方法def getStringEncoding(self, string)和解密方法def getStringDecoding(self, encoding)完成的。加密的大致过程是：初始化一个解密字符串encoding，然后用encodingList即单词和编码的字典中的单词一一匹配明文开头单词，如果匹配上了，将密文加入encoding，然后明文从下一个单词开头重复上一个步骤的匹配工作，以此类推，直到全部加密完成。解密步骤反之同理。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoding</span>: </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, encodingList)</span></span>: </div><div class="line">        <span class="keyword">self</span>.encodingList = encodingList </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStringEncoding</span><span class="params">(<span class="keyword">self</span>, string)</span></span>: </div><div class="line">        encoding = <span class="string">''</span> </div><div class="line">        <span class="keyword">while</span> string != <span class="string">''</span>: </div><div class="line">            flag = <span class="number">0</span> </div><div class="line">            <span class="keyword">for</span> (k, v) <span class="keyword">in</span> <span class="keyword">self</span>.encodingList.items(): </div><div class="line">                <span class="keyword">if</span> string.startswith(k) <span class="keyword">and</span> string[len(k)] == <span class="string">' '</span>:  <span class="comment">#判断明文字符串是否以字典中存在的单词开头</span></div><div class="line">                    encoding += v     <span class="comment"># 如果成功匹配到单词，encoding密文字符串加入相应的单词编码</span></div><div class="line">                    string = string[len(k) + <span class="number">1</span><span class="symbol">:</span>]    <span class="comment">#明文字符串跳过单词之间的空格，从下一个单词继续加密</span></div><div class="line">                    flag = <span class="number">1</span> </div><div class="line">                    <span class="keyword">break</span> </div><div class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>: </div><div class="line">                    raise  Exception </div><div class="line">        <span class="keyword">return</span> encoding </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStringDecoding</span><span class="params">(<span class="keyword">self</span>, encoding)</span></span>: </div><div class="line">        string = <span class="string">''</span> </div><div class="line">        <span class="keyword">while</span> encoding != <span class="string">''</span>: </div><div class="line">            flag = <span class="number">0</span> </div><div class="line">            <span class="keyword">for</span> (k, v) <span class="keyword">in</span>  <span class="keyword">self</span>.encodingList.items(): </div><div class="line">                <span class="keyword">if</span> encoding.startswith(v):   <span class="comment">#判断密文字符串是否以字典中存在的密文编码开头</span></div><div class="line">                    string += k </div><div class="line">                    string += <span class="string">' '</span> </div><div class="line">                    encoding = encoding[len(v)<span class="symbol">:</span>]   <span class="comment">#密文字符串继续从下一个单词编码解密</span></div><div class="line">                    flag = <span class="number">1</span> </div><div class="line">                    <span class="keyword">break</span> </div><div class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>: </div><div class="line">                raise Exception </div><div class="line">        <span class="keyword">return</span> string</div></pre></td></tr></table></figure>
<h3 id="4-3-NodeDataIO-py模块核心代码"><a href="#4-3-NodeDataIO-py模块核心代码" class="headerlink" title="4.3 NodeDataIO.py模块核心代码"></a>4.3 NodeDataIO.py模块核心代码</h3><p>NodeDataIO类中最重要的就是初始化方法，它的功能是从password dictionary文件夹中随机选择一个加密字典，进行加密工作。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span>: </div><div class="line">    root = <span class="string">"/Users/zhangchuyue/Desktop/B15040805张楚月_哈夫曼加解密工具/password dictionary"</span> </div><div class="line">    file_names = [] </div><div class="line">    <span class="keyword">for</span> parent, catalog, filename <span class="keyword">in</span> os.walk(root): </div><div class="line">        file_names = filename </div><div class="line">    file_names.remove(<span class="string">'.DS_Store'</span>) </div><div class="line">    x = random.randint(<span class="number">0</span>, len(file_names) - <span class="number">1</span>) </div><div class="line">    <span class="keyword">self</span>.fileName1 = file_names[x] </div><div class="line">    print(<span class="string">"choose a password dictionary: "</span> + <span class="keyword">self</span>.fileName1) </div><div class="line"><span class="keyword">self</span>.fr = open(<span class="string">"/Users/zhangchuyue/Desktop/B15040805张楚月_哈夫曼加解密工具/password  </span></div><div class="line"><span class="string">       "</span>dictionary/<span class="string">"  + self.fileName1, 'r', encoding='utf-8', errors='ignore')</span></div></pre></td></tr></table></figure>
<h3 id="4-4-decode-py模块核心代码"><a href="#4-4-decode-py模块核心代码" class="headerlink" title="4.4 decode.py模块核心代码"></a>4.4 decode.py模块核心代码</h3><p>与NodeDataIO类功能类似，除了初始化代码以外都相同。不过NodeDataIO负责加密，Decode类负责解密，解密根据字典编码选择相应字典，实现代码为Decode类的初始化方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, fr)</span></span>: </div><div class="line"><span class="keyword">self</span>.fr = fr</div></pre></td></tr></table></figure>
<p>通过在Dialog.pyw MyDialog类中的def decode(self)方法中调用获得随机字典的文件名：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">de_fr = <span class="keyword">open</span>(<span class="comment">"/Users/zhangchuyue/Desktop/B15040805张楚月_哈夫曼加解密工具/password     </span></div><div class="line">        <span class="string">"dictionary/dictionary"</span> + self.<span class="built_in">count</span> + <span class="string">'.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) </div><div class="line"><span class="keyword">new</span> = Decode(de_fr)</div></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="5-测试数据及其结果分析"><a href="#5-测试数据及其结果分析" class="headerlink" title="5.测试数据及其结果分析"></a>5.测试数据及其结果分析</h2><h3 id="5-1-合法数据输入-理想-amp-实际输出示例"><a href="#5-1-合法数据输入-理想-amp-实际输出示例" class="headerlink" title="5.1 合法数据输入-理想&amp;实际输出示例"></a>5.1 合法数据输入-理想&amp;实际输出示例<br></h3><p>输入：<br>my name is xliii he is my professor<br>输出：11110101111011011010110001001111011101001110001010010111000100111111011101001101101101010100110011<br>（choose a password dictionary: dictionary983.txt，此示例随机选择了dictionary983.txt进行加密）<br><img src="http://ojv7wbfak.bkt.clouddn.com/%E5%90%88%E6%B3%95%E8%BE%93%E5%85%A5.png" alt="image"><br></p>
<h3 id="5-2-合法数据输入-错误输出示例"><a href="#5-2-合法数据输入-错误输出示例" class="headerlink" title="5.2 合法数据输入-错误输出示例"></a>5.2 合法数据输入-错误输出示例</h3><p>输入：<br>who is he<br>点击：<br>将加密结果导出到文件<br>现象：<br>未产生加密结果，进行except异常处理，弹出警告弹窗——没有可写字符<br><img src="http://ojv7wbfak.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E8%BE%93%E5%87%BA.png" alt="image"><br></p>
<h3 id="5-3-非法数据输入-错误输出示例"><a href="#5-3-非法数据输入-错误输出示例" class="headerlink" title="5.3 非法数据输入-错误输出示例"></a>5.3 非法数据输入-错误输出示例</h3><p>输入：<br>dfwe fdd qewrqr<br>（输入为单词字典中不存在的单词）<br>输出：<br>进行except异常处理，弹出错误弹窗——您输入的文本中包含未编码的字符，请重新输入！<br><img src="http://ojv7wbfak.bkt.clouddn.com/%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5.png" alt="image"><br><br></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>python自带的tkinter库比较好用，但是实现的gui真的很丑。wxpython也应为各种坑装不了，大概是因为wxpython只能应用于32位的python……两周忙忙碌碌总算是做出来了，有时候码到深夜，饿到昏厥，不过结果还是挺好的，继续加油！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-写在开头&quot;&gt;&lt;a href=&quot;#1-写在开头&quot; class=&quot;headerlink&quot; title=&quot;1.写在开头&quot;&gt;&lt;/a&gt;1.写在开头&lt;/h2&gt;&lt;p&gt;本学期程序设计周的题目，利用哈夫曼算法实现了一个加解密的工具。&lt;/p&gt;
&lt;p&gt;基本要求：&lt;br&gt;(1) 根据
    
    </summary>
    
      <category term="Code" scheme="http:/categories/code/"/>
    
    
      <category term="Python" scheme="http:/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用python实现的猜数字小游戏</title>
    <link href="http:/2017/10/16/%E7%94%A8python%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%8C%9C%E6%95%B0%E5%AD%97%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>http:/2017/10/16/用python实现的猜数字小游戏/</id>
    <published>2017-10-16T12:36:42.000Z</published>
    <updated>2017-10-16T13:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>跟着教程写了一个简单的python程序。<br></p>
<p>实现的功能是：输入玩家姓名后，给了个1～100的随机数，玩家一步步猜测，程序会记录该用户游戏玩的次数、猜中数字的游戏次数中最少的一次轮数、所有游戏次数的总轮数，然后计算得到猜中数字需要的平均轮数输出。<br></p>
<p>一个比较简单的练习，不过语法还在慢慢熟练过程中，每行语义还是值得细细思考的。主要运用了列表、字典、文件读取及涉及的部分函数，并配合基本的循环结构写的。<br></p>
<p>之前自己看教程用pycharm3.6的版本写，教程还是py2的，自己还要一个个琢磨py2和py3的区别，对语法了解阶段有点耗时。毕竟区别不大，打算熟练了之后再去习惯py3，所以这个程序用的是python自带的IDLE写的，mac端不太友好，字体及细，下划线‘_’看不到，备注切换中文输入法还出不来，只能英文（摔。<br></p>
<p>另，最后暂时选用了有道云笔记来写md，之前一直用我的印象，微博看到干货直接@一下甩上去，后来发现除非霸王硬上弓，我的印象似乎是不能写md了，于是现在的情况是md用有道云写，干货收录在我的印象。<br><br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">from random import randint</div><div class="line"></div><div class="line">name = raw_input(<span class="string">'input your name:'</span>) <span class="comment">#输入玩家姓名</span></div><div class="line">f = <span class="keyword">open</span>(<span class="string">'/Users/zhangchuyue/Desktop/python/猜数字/game.txt'</span>)</div><div class="line">lines = f.readlines() <span class="comment">#读取所有行</span></div><div class="line">f.close()</div><div class="line"></div><div class="line">scores = &#123;&#125; <span class="comment">#用一个空字典纪录成绩</span></div><div class="line"><span class="keyword">for</span> l in lines:</div><div class="line">    <span class="keyword">s</span> = l.<span class="keyword">split</span>() <span class="comment">#把每行数据拆分为列表</span></div><div class="line">    scores[<span class="keyword">s</span>[<span class="number">0</span>]] = <span class="keyword">s</span>[<span class="number">1</span>:] <span class="comment">#s[0]为key，其余为value</span></div><div class="line">score = scores.get(name) <span class="comment">#按key获取相应value</span></div><div class="line"><span class="keyword">if</span> score is None: <span class="comment">#若无该key返回None</span></div><div class="line">    score = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</div><div class="line">    </div><div class="line">game_times = <span class="keyword">int</span>(score[<span class="number">0</span>]) <span class="comment">#score第一个存放游戏次数</span></div><div class="line">min_times = <span class="keyword">int</span>(score[<span class="number">1</span>]) <span class="comment">#第二个存放猜中所花的最小轮数</span></div><div class="line">total_times = <span class="keyword">int</span>(score[<span class="number">2</span>]) <span class="comment">#总轮数</span></div><div class="line"><span class="keyword">if</span> game_times &gt; <span class="number">0</span>: <span class="comment">#0不能为除数，单独判断</span></div><div class="line">    avg_times = float(total_times) / game_times</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    avg_times = <span class="number">0</span></div><div class="line"><span class="keyword">print</span> <span class="string">'you have played %d times, minum %d round, average %d round'</span> %(game_times,min_times,avg_times)</div><div class="line"></div><div class="line">num = randint(<span class="number">1</span>,<span class="number">100</span>) </div><div class="line"><span class="keyword">times</span> = <span class="number">0</span></div><div class="line"><span class="keyword">print</span> <span class="string">'guess what i think?'</span></div><div class="line">bingo = False</div><div class="line"><span class="keyword">while</span> bingo == False:</div><div class="line">    <span class="keyword">times</span> += <span class="number">1</span></div><div class="line">    answer = input()</div><div class="line">    <span class="keyword">if</span> answer &lt; num:</div><div class="line">        <span class="keyword">print</span> <span class="string">'too small'</span></div><div class="line">    elif answer == num:</div><div class="line">        <span class="keyword">print</span> <span class="string">'bingo'</span></div><div class="line">        bingo = True</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">'too big'</span></div><div class="line">        </div><div class="line"><span class="keyword">if</span> game_times == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">times</span> &lt; min_times:</div><div class="line">    min_times = <span class="keyword">times</span></div><div class="line">total_times += <span class="keyword">times</span></div><div class="line">game_times += <span class="number">1</span></div><div class="line"></div><div class="line">scores[name] = [str(game_times), str(min_times), str(total_times)] <span class="comment">#更新scores里的成绩，如果直接写入文件，其他玩家的成绩会被覆盖</span></div><div class="line">result = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> n in scores:</div><div class="line">    line = n + <span class="string">' '</span> + <span class="string">' '</span>.join(scores[n])  +<span class="string">'\n'</span> <span class="comment">#用‘ ’连接scores[n]</span></div><div class="line">    result += line</div><div class="line"></div><div class="line">f = <span class="keyword">open</span>(<span class="string">'/Users/zhangchuyue/Desktop/python/猜数字/game.txt'</span>, <span class="string">'w'</span>)</div><div class="line">f.write(result)</div><div class="line">f.close()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着教程写了一个简单的python程序。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;实现的功能是：输入玩家姓名后，给了个1～100的随机数，玩家一步步猜测，程序会记录该用户游戏玩的次数、猜中数字的游戏次数中最少的一次轮数、所有游戏次数的总轮数，然后计算得到猜中数字需要的平均轮数输出。&lt;br&gt;&lt;
    
    </summary>
    
      <category term="Code" scheme="http:/categories/code/"/>
    
    
      <category term="Python" scheme="http:/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>科技节手机UI主题设计大赛</title>
    <link href="http:/2017/07/13/%E7%A7%91%E6%8A%80%E8%8A%82%E6%89%8B%E6%9C%BAui%E4%B8%BB%E9%A2%98%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <id>http:/2017/07/13/科技节手机ui主题设计大赛/</id>
    <published>2017-07-13T08:58:52.000Z</published>
    <updated>2018-01-16T08:54:07.508Z</updated>
    
    <content type="html"><![CDATA[<p>这个比赛其实是半年前的了，因为最近在休整博客，准备把一些设计和摄影的作品也都慢慢放进来，所以翻了些陈年旧事。</p>
<p>当时学校科技节，有不少比赛。大一的时候其实也报了这个比赛的名，因为懒，后来并没有提交作品（逃），大二为了水点自主化学分，感觉这个比赛比较稳，于是花了一周的时间做这套UI。（捂脸<br>比赛毕竟还是比赛，评委还是那些老师，那肯定不能按套路来……所以果断地避开了扁平和渐变之类的设计潮流，也规避了极简，选择了偏拟物的中国风，颜色也选的都是饱和度比较低的。</p>
<p>icon细节上考虑的比较多（虽然实际使用上并不容易注意到），只是强行给自己加戏…||| 所以一定要讲解一下……</p>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/icons%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<p><br></p>
<blockquote>
<p>便签：毛笔。</p>
<p>备份恢复：云备份。</p>
<p>拨号：中间是一块黑色的鹅卵石，撞击在沙粒中产生了圆形的波纹，取自含义“一沙一世界“。类比声波。<br>浏览器：古人望月，一览苍穹。</p>
<p>联系人：以汉服表示。</p>
<p>日历：日晷，表示日期时间的变化。</p>
<p>视频：一盏俯视的茶水，水面上的三片茶叶拼成了视频播放的三角形的标志。</p>
<p>文件管理：信封，加上了古代宣纸的质感。</p>
<p>天气：以祥云的纹理，勾勒出水滴的轮廓，用画笔画出水滴的光泽。</p>
<p>信息：木质底纹，信纸上写有“红豆生南国，春来发几枝。“因为相思，所以寄信传情。</p>
<p>图库(为上图的’相册’)：一朵莲花。</p>
<p>主题风格：以竹子的“竹“取谐音主题的”主“，竹子高风亮节的品格也正好对应了主题风格中的”风“。</p>
<p>音乐：一把琵琶的琴头，。</p>
<p>相机：用砚台磨墨的圆形区域表示相机的镜头。</p>
<p>游戏：围棋。</p>
<p>设置：规避大众普遍的设计如齿轮、榔头等，以古代木质建筑的常用结构——卯榫 表示。</p>
</blockquote>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/%E9%94%81%E5%B1%8F%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/%E5%A4%A9%E6%B0%94%E5%8C%BA%E5%9F%9F%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/%E9%9F%B3%E4%B9%90%E5%8C%BA%E5%9F%9F%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/%E7%95%8C%E9%9D%A2%E5%9B%9B1%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<blockquote>
<p>界面二——天气widget区域，天气widget是一个平头案，平头案是一种独具特色的汉族传统的明式家具。</p>
<p>界面三——音乐widget，音乐widget是一副画卷。</p>
</blockquote>
<p>最后提交的作品改了锁屏壁纸，虽然个人还是更喜欢纯色的宣纸质感背景Q w Q</p>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/%E8%90%BD%E6%A2%85%E7%AC%BA%20template%E5%89%AF%E6%9C%AC.jpg" alt=""></p>
<p>至于为什么给这套作品取名为《落梅笺》，一是因为要体现它的古风，二是因为壁纸上有一枝梅花，于是取自于银临的一首歌名。<br><br><br><br></p>
<blockquote>
<p>昨夜桃花开 几抹浓淡春色里外</p>
<p>唯恐着尘埃 执手相看流连还来</p>
<p>忽的蝉尽秋已到 花飞梦散对空梢</p>
<p>风月如雪泥鸿爪 蝇头细字终潦草</p>
</blockquote>
<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28188433&auto=1&height=66"></iframe></div>









]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个比赛其实是半年前的了，因为最近在休整博客，准备把一些设计和摄影的作品也都慢慢放进来，所以翻了些陈年旧事。&lt;/p&gt;
&lt;p&gt;当时学校科技节，有不少比赛。大一的时候其实也报了这个比赛的名，因为懒，后来并没有提交作品（逃），大二为了水点自主化学分，感觉这个比赛比较稳，于是花了一
    
    </summary>
    
      <category term="Design" scheme="http:/categories/design/"/>
    
    
      <category term="UI Design" scheme="http:/tags/ui-design/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现三转轮密码机加密</title>
    <link href="http:/2017/03/18/c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%BD%AC%E8%BD%AE%E5%AF%86%E7%A0%81%E6%9C%BA%E5%8A%A0%E5%AF%86/"/>
    <id>http:/2017/03/18/c语言实现三转轮密码机加密/</id>
    <published>2017-03-18T04:16:51.000Z</published>
    <updated>2018-01-16T08:57:23.085Z</updated>
    
    <content type="html"><![CDATA[<p>博客没有死，只是一直想不到可以写的东西，如果再不更新，生活也许只剩眼前的雾霾了。所以打算写些学习和生活的二三事，从今天开始吧。<br><br><br><img src="http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170317211036.jpg" alt=""><br><br><br>三转轮密码机的工作原理如图，简单补充一下：</p>
<blockquote>
<p>快轮子转动一圈（26个位置），中轮子转动一个位置；中轮子转动一圈（26个位置），慢轮子转动一个位置。在加密或解密26×26×26个字母以后，所有转轮都恢复到初始状态（如图3-1(a)）。由此，一个有3个转轮的转轮密码机是一个密钥周期为26×26×26 = 17 576的多表代换密码机械装置。</p>
</blockquote>
<p>原理其实和<a href="https://en.wikipedia.org/wiki/Enigma_machine" target="_blank">Enigma machine</a>类似，在二战时期被运用过。<br><br><br>盯着图看了两三天，直到着手写的时候也依然没有思路，那就先照着图上的索引一步一步加密看看吧。于是对照着初始状态以及转轮转动规则采用数组写，写着写着写出了一点思路：<br><br></p>
<ol>
<li>先将26个字母改为1~26的数字表示，使明文字母对应慢轮子左列的26个数字；<br><br></li>
<li>依次搜索慢轮子右列直到找到与明文相同的数字，记录数字所在行数，进入同行的中轮子左列；<br><br></li>
<li>方法同（2），转入快轮子；<br><br></li>
<li>依次搜索快轮子右列直到搜索到与快轮子左列相同的数字，输出数字所在行数，将数字转换为字母，密文输出；<br><br></li>
<li>快轮转动一个位置；<br><br></li>
<li>判断加密次数是否为26的倍数，若满足，则中轮子转动一个位置；<br><br></li>
<li>判断加密次数是否为26×26的倍数，若满足，则慢轮子转动一个位置；<br><br></li>
<li>一个字母加密结束。<br><br></li>
</ol>
<p>以这种方式解密也是比较容易的，只要从密文输出的地方按照线路索引逆向走回去就可输出明文。<br><br><br>在加密时，本想偷懒跳过空格以及标点的处理，但这样会造成密文包含原始空格以及标点，于是在文件处理上，我先删除了空格和标点，再进行读取文件加密。<br><br><br>以下附上核心代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//三转轮密码机加密函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncryptFile</span> <span class="params">(<span class="keyword">char</span> buffer[], <span class="keyword">int</span> FileSize)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i, j, m;</div><div class="line">    <span class="keyword">int</span> flag = <span class="number">-1</span>, num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sRotor[<span class="number">26</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> mRotor[<span class="number">26</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> fRotor[<span class="number">26</span>][<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> arr[<span class="number">1</span>][<span class="number">2</span>];</div><div class="line"></div><div class="line">    sRotor[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">24</span>; sRotor[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">21</span>;</div><div class="line">    sRotor[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">25</span>; sRotor[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">3</span>;</div><div class="line">    <span class="comment">//此段为冗长的慢中快轮子sRotor\mRotor\fRotor数据存储,不一一列写</span></div><div class="line">    fRotor[<span class="number">24</span>][<span class="number">0</span>] = <span class="number">25</span>; fRotor[<span class="number">24</span>][<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    fRotor[<span class="number">25</span>][<span class="number">0</span>] = <span class="number">26</span>; fRotor[<span class="number">25</span>][<span class="number">1</span>] = <span class="number">14</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FileSize; i++) &#123;     <span class="comment">//将文档所有A~Z的字母转为1~26的数字表示</span></div><div class="line">        <span class="keyword">if</span> (buffer[i] &gt;= <span class="string">'A'</span> &amp;&amp; buffer[i] &lt;= <span class="string">'Z'</span>) &#123;</div><div class="line">            buffer[i] -= <span class="number">64</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buffer[i] &gt;= <span class="string">'a'</span> &amp;&amp; buffer[i] &lt;= <span class="string">'z'</span>) &#123;</div><div class="line">            buffer[i] -= <span class="number">96</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FileSize; i++) &#123;     <span class="comment">//明密文转换</span></div><div class="line">        num++;     <span class="comment">//记录加密次数</span></div><div class="line">        <span class="keyword">if</span> (buffer[i] &gt;= <span class="number">1</span> &amp;&amp; buffer[i] &lt;= <span class="number">26</span>) &#123;     </div><div class="line">            m = sRotor[buffer[i] - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</div><div class="line">                flag++;</div><div class="line">                <span class="keyword">if</span> (sRotor[j][<span class="number">1</span>] == m) &#123;</div><div class="line">                    m = sRotor[j][<span class="number">1</span>];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            m = mRotor[flag][<span class="number">0</span>];</div><div class="line">            flag = <span class="number">-1</span>;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</div><div class="line">                flag++;</div><div class="line">                <span class="keyword">if</span> (mRotor[j][<span class="number">1</span>] == m) &#123;</div><div class="line">                    m = mRotor[j][<span class="number">1</span>];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            m = fRotor[flag][<span class="number">0</span>];</div><div class="line">            flag = <span class="number">-1</span>;</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</div><div class="line">                flag++;</div><div class="line">                <span class="keyword">if</span> (fRotor[j][<span class="number">1</span>] == m) &#123;</div><div class="line">                    m = fRotor[j][<span class="number">1</span>];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            buffer[i] = flag + <span class="number">49</span> + <span class="string">'0'</span>;     <span class="comment">//密文输出为字母</span></div><div class="line">            flag = <span class="number">-1</span>;     <span class="comment">//flag回到初始值</span></div><div class="line">            arr[<span class="number">0</span>][<span class="number">0</span>] = fRotor[<span class="number">25</span>][<span class="number">0</span>];     <span class="comment">//快轮转动一个位置</span></div><div class="line">            arr[<span class="number">0</span>][<span class="number">1</span>] = fRotor[<span class="number">25</span>][<span class="number">1</span>];</div><div class="line">            <span class="keyword">for</span> (j = <span class="number">25</span>; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">                fRotor[j][<span class="number">0</span>] = fRotor[j - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">                fRotor[j][<span class="number">1</span>] = fRotor[j - <span class="number">1</span>][<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">            fRotor[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">            fRotor[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>][<span class="number">1</span>];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (num % <span class="number">26</span> == <span class="number">0</span>) &#123;     <span class="comment">//若快轮已转动一圈则中轮转动一个位置</span></div><div class="line">                arr[<span class="number">0</span>][<span class="number">0</span>] = mRotor[<span class="number">25</span>][<span class="number">0</span>];     <span class="comment">//中轮转动一个位置</span></div><div class="line">                arr[<span class="number">0</span>][<span class="number">1</span>] = mRotor[<span class="number">25</span>][<span class="number">1</span>];</div><div class="line">                <span class="keyword">for</span> (j = <span class="number">25</span>; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">                    mRotor[j][<span class="number">0</span>] = mRotor[j - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">                    mRotor[j][<span class="number">1</span>] = mRotor[j - <span class="number">1</span>][<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                mRotor[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">                mRotor[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>][<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (num % (<span class="number">26</span> * <span class="number">26</span>) == <span class="number">0</span>) &#123;     <span class="comment">//若中轮已转动一圈则慢轮转动一个位置</span></div><div class="line">                arr[<span class="number">0</span>][<span class="number">0</span>] = sRotor[<span class="number">25</span>][<span class="number">0</span>];     <span class="comment">//慢轮转动一个位置</span></div><div class="line">                arr[<span class="number">0</span>][<span class="number">1</span>] = sRotor[<span class="number">25</span>][<span class="number">1</span>];</div><div class="line">                <span class="keyword">for</span> (j = <span class="number">25</span>; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">                    sRotor[j][<span class="number">0</span>] = sRotor[j - <span class="number">1</span>][<span class="number">0</span>];</div><div class="line">                    sRotor[j][<span class="number">1</span>] = sRotor[j - <span class="number">1</span>][<span class="number">1</span>];</div><div class="line">                &#125;</div><div class="line">                sRotor[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">                sRotor[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>][<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    buffer[FileSize] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//删除文件里空格标点的函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileDelete</span> <span class="params">()</span> </span>&#123;</div><div class="line">    FILE *fp, *fp2;</div><div class="line">    <span class="keyword">int</span> p;</div><div class="line">    <span class="keyword">char</span> filename[<span class="number">20</span>];</div><div class="line">    <span class="keyword">char</span> filename2[<span class="number">20</span>];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"加密前,文件需要删去空格以及标点,请输入要加密文件路径: \n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    fp = fopen(filename, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"删去空格以及标点后,请输入需加密文件的另存为路径: \n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename2);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    fp2 = fopen(filename2, <span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span>((fp = fopen(filename,<span class="string">"r"</span>)) != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">while</span>((p = fgetc(fp)) != EOF ) &#123;</div><div class="line">            <span class="keyword">if</span>(p &gt;= <span class="number">65</span> &amp;&amp; p &lt;= <span class="number">90</span> || p &gt;= <span class="number">97</span> &amp;&amp; p &lt;= <span class="number">122</span>) &#123;</div><div class="line">                fputc(p,fp2);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    fclose(fp);</div><div class="line">    fclose(fp2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//打开源文件</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">openSrcFile</span> <span class="params">(<span class="keyword">char</span> **buffer)</span> </span>&#123;</div><div class="line">    FILE *MyfileSrc;     <span class="comment">//源文件指针</span></div><div class="line">    <span class="keyword">char</span> filename[<span class="number">20</span>];    <span class="comment">//文件名数组</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">int</span> FileSize;     <span class="comment">//记录文件的长度</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i,j;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要加密的文件路径：\n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">if</span> (!(MyfileSrc = fopen(filename,<span class="string">"rb"</span>))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</div><div class="line">    &#125;;</div><div class="line">    fseek(MyfileSrc, <span class="number">0</span>, SEEK_END);     <span class="comment">//判断文件长度</span></div><div class="line">    FileSize = ftell(MyfileSrc);</div><div class="line">    fseek(MyfileSrc, <span class="number">0</span>, SEEK_SET);</div><div class="line">    *buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(FileSize);     <span class="comment">//像堆区申请FileSize大小内存空间</span></div><div class="line">    fread(*buffer, <span class="number">1</span>, FileSize, MyfileSrc);     <span class="comment">//读入文件</span></div><div class="line">    fclose(MyfileSrc);</div><div class="line">    <span class="keyword">return</span> FileSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//储存加密文件</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveDstFile</span> <span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> FileSize)</span> </span>&#123;</div><div class="line">    FILE *MyfileDst;     <span class="comment">//源文件指针</span></div><div class="line">    <span class="keyword">char</span> filename[<span class="number">20</span>];     <span class="comment">//文件名数组</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"请输入文件加密后要生成的路径：\n"</span>);</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, filename);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">if</span> (!(MyfileDst = fopen(filename,<span class="string">"wb"</span>))) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Error!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">fprintf</span>(MyfileDst, <span class="string">"%s"</span>, buffer);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"加密完成，请查看加密生成文件\n"</span>);</div><div class="line">    fclose(MyfileDst);</div><div class="line">    <span class="built_in">free</span>(buffer);     <span class="comment">//释放内存空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><br><br><br><img src="http://ojv7wbfak.bkt.clouddn.com/%E5%9B%BE%E4%BE%8B.png" alt=""><br><em><div align="center">测试图例</div></em><br><br><br>由于写的比较赶，风格和习惯上的不足还望见谅。错误之处敬请斧正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客没有死，只是一直想不到可以写的东西，如果再不更新，生活也许只剩眼前的雾霾了。所以打算写些学习和生活的二三事，从今天开始吧。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8
    
    </summary>
    
      <category term="Code" scheme="http:/categories/code/"/>
    
    
      <category term="C" scheme="http:/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Long Live Twenty!</title>
    <link href="http:/2017/01/27/20/"/>
    <id>http:/2017/01/27/20/</id>
    <published>2017-01-27T07:12:07.000Z</published>
    <updated>2018-01-16T08:59:29.427Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170127151308.jpg" alt=""><br><br><br>今天是除夕了，又这么巧在今天满了20岁，是不是可以奢侈地许两个愿望呢？<br><br><br>据说在除夕过生日，这是我第二次。第一次的时候，我才一岁，人生刚刚开始。今天，也算又一个开始吧，毫无准备地要开始二字打头的生活，满脑子都是未来十年的幻影，想想竟有点不知所措。<br><br><br>回顾过去，我真觉得十八岁半实在是太棒了。那段时间里做的每一件事情似乎都关乎未来的走向，自己却没有任何来自外界的压力和负担，可以深呼吸、大胆地为自己的将来做决定。也许这就是自己作为法定的成年人体会到的第一次责任，原来长大这么好。可是，岁月它像开了阀的洪水一样，奔腾不息，偶有溅起的水花让你感叹一下蹉跎，却又不得不无畏大浪，顺水而行。曾经期待着长大，渴求独立的思想，盼望自己有一天成为一个标新立异的新青年，然而真正长大了，却无比觊觎一个可以堵住滚滚洪水的坝，让它流缓点儿，再缓点儿。<br><br><br>我总是认为，二十多了，是该陆续兑现一点承诺了。可是，我从小到大的两个纯粹的梦想，目前似乎无一实现，好像有点讽刺。这个寒假，可以说是近期最抑郁的假期了，对着键盘无力地敲打，不知觉就到了深夜，不知觉就这样迎接二十岁。会多想，会绝望。哎，不过也好在，梦想虽有取舍，但没有变过，即使目前压抑悲观，偶尔无力绝望，不过总会“沉舟侧畔千帆过，病树前头万木春”的吧！毕竟，它是这样一个被多少过来人羡慕的黄金时代，是这样生猛又刚硬。<br><br><br>身边的大家也陆续步入桃李、弱冠之年，这才意识到，“从前”，是真的走了。渐渐发现很多事情自己已经没有小时候那种面对的感觉。现在会怕老，看到老人脸上的皱纹会心酸；有时会觉得假期出游也挺无趣的；小时候难得去次上海才吃得到的M记云云现在虽然烂了大街，但一点儿也不好吃了；小时候逢五一、国庆就有喜酒吃，现在越来越少了……原来大家都长大了啊。<br><br><br>未来，势必会遇到越来越多形形色色的人。我是人海中一个小小的分子，愿南方的阴雨，淋不湿我，北方的鸿雁，也能被我看到啼破苍穹。愿日落江河之时，也能缓步当歌，看星辰飘落。在二十几岁的日子里，希望一切都好，我要敢爱，敢拼，敢闯，风中造舟，不再回头。</p>
<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32272267&auto=1&height=66"></iframe></div>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170127151308.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;今天是除夕了，又这么巧在今天满了20岁，是不是可以奢侈地许两个愿望呢？
    
    </summary>
    
      <category term="Daily Life" scheme="http:/categories/daily-life/"/>
    
    
      <category term="daily" scheme="http:/tags/daily/"/>
    
  </entry>
  
  <entry>
    <title>Serendipity</title>
    <link href="http:/2017/01/17/serendipity/"/>
    <id>http:/2017/01/17/serendipity/</id>
    <published>2017-01-17T06:27:24.000Z</published>
    <updated>2017-07-13T08:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>你来了，真是件serendipity。 <br><br><br>寒假回来这几天忙着搭blog，终于差不多成型了。之前在hexo+github和wordpress两者之间纠结了一会，最后还是选择使用前者。虽然两者各有所长，选择哪种方法都会有点小小的欠缺，不过为了借机会使用下github，还是决定搭这个轻量级的blog。<br><br><br><img src="http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170117150415.jpg" alt=""><br><br><br><br>主题上我不喜欢太复杂的，也不想要太极简的，所以选了很久。记得概率论老师上课说过一次</p>
<blockquote>
<p>也许继续下去可以找到更适合你的，但你不可能一直找下去。  </p>
</blockquote>
<p>好吧，那就这个主题了。小改了一点，把顶部logo的部分换成了之前<a href="http://weibo.com/u/2865004400" target="_blank">@眼眼</a>帮我画的头像，为了做成png索引，轮廓被我抠得比较粗糙，233。网页端标签页前面的小图标和apple touch icon也改了，正好上学期参加UI比赛，花了一周做了一套国风的UI，就找了一个当时画的月亮来当icon，突然觉得跟主题风格还挺搭的，满页移动的都是星星，就差一个月亮了嘛！( 做的是类似塞班的图标形状，ios里看还挺违和 ) 细节上也是在尽量改成更像自己的一个blog，不过还是觉得布局不是特别满意，评论区暂时没打算开，感觉不是很有必要，再看吧，慢慢改。<br><img src="http://ojv7wbfak.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170117150254.jpg" alt=""><br><br><br><br>最近看了《Serendipity》。它残忍、悲哀，实际上不是一个美好的爱情故事，可它是一个好单词。维基百科上对它是这么解释的</p>
<blockquote>
<p>意外发现（Serendipity [ˌserənˈdɪpəti] ）是指某人发现了他原先没有期待发现的事物或现象。英文原词是“Serendipity”，这个英文单词曾在2004年6月被一家英国翻译公司评选为十大最难翻译的单词，不过，这个单词已经被转译成多个语言。单词可以简单的理解为幸福的意外（happy accident）或愉快的惊喜（pleasant surprise）。</p>
</blockquote>
<p>其实并不觉得这个解释是最好的，过于平实。而电影翻译来为《缘分天注定》，字幕里解释为“情有独钟”，这些又太优雅。平凡地看它，就是“机缘凑巧”、“巧事”之类的吧。所以我说，你来了，就是serendipity了。<br><br><br><br>印象最深刻的是男主死党为他写的“悼言”，作为全片的精髓，太美不过。</p>
<blockquote>
<p>Jonathan Trager, prominent television producer for ESPN, died last night from complications of losing his soul mate and his fiance.<br><br> He was thirty-five years old. Soft-spoken and obsessive, Trager never looked the part of a hopeless romantic. But in the final days of his life, he revealed an unknown side of his psyche. This hidden quasi-Jungian persona surfaced during the Agatha Christie-like pursuit for his long, reputed soul mate; a woman whom he only spent a few precious hours with. Sadly, the protracted search ended late Saturday night in complete and utter failure. Yet even in certain defeat, the courageous Trager secretly clung to the belief that life is not merely a series of meaningless accidents or coincidences. Uh-uh. But rather, it is a tapestry of events that culminate into an exquisite, sublime plan. <br><br>Ask about the loss of his dear friend, Dean Kansky, the Pulitzer Prize-winning author and executive editor of New York Times, described Jonathan as a changed man in the last days of his life. Things were clearer for him, Kansky noted. Ultimately, Jonathan concluded that if we are to live life in harmony with the universe we must all possess a powerful faith, of what the ancients used to call fatum; what we currently refer to as destiny.</p>
</blockquote>
<p><img src="http://ojv7wbfak.bkt.clouddn.com/2017-01-17.png" alt=""><br>电影最后以一片星辰到漆黑的夜空结束，好像这就是所谓的destiny。 <br><br><br>就让SERENDIPITY好好地生长下去吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你来了，真是件serendipity。 &lt;br&gt;&lt;br&gt;&lt;br&gt;寒假回来这几天忙着搭blog，终于差不多成型了。之前在hexo+github和wordpress两者之间纠结了一会，最后还是选择使用前者。虽然两者各有所长，选择哪种方法都会有点小小的欠缺，不过为了借机会使用下g
    
    </summary>
    
      <category term="Daily Life" scheme="http:/categories/daily-life/"/>
    
    
      <category term="daily" scheme="http:/tags/daily/"/>
    
  </entry>
  
</feed>
